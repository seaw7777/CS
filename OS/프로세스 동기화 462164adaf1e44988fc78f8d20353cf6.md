# 프로세스 동기화

Data Structure: Asyncronous, Process, Syncronous

# 동기 vs 비동기

### **동기(synchronous : 동시에 일어나는)**

- 동기는 말 그대로 동시에 일어난다는 뜻입니다. 요청과 그 결과가 동시에 일어난다는 약속인데요. 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야 합니다.

**> 요청과 결과가 한 자리에서 동시에 일어남**

**> A노드와 B노드 사이의 작업 처리 단위(transaction)를 동시에 맞추겠다.**

### **비동기(Asynchronous : 동시에 일어나지 않는)**

- 비동기는 동시에 일어나지 않는다를 의미합니다. 요청과 결과가 동시에 일어나지 않을거라는 약속

**> 요청한 그 자리에서 결과가 주어지지 않음**

**> 노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.**

![%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled.png](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled.png)

### 장단점

![%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%201.png](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%201.png)

# 블로킹 vs 논블로킹

**다른 작업을 수행하는 주체를 어떻게 상대하는지가 중요**

### Blocking I/O

자신의 작업을 하다가 다른 작업 주체가 하는 작업의 시작부터 끝까지 기다렸다가 다시 자신의 작업을 시작

### NonBlocking I/O

다른 주체의 작업과 관계없이 자신의 작업을 계속함

![%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%202.png](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%202.png)

---

# 프로세스 동기화

### 임계영역(Critical Section)

둘 이상의 프로세스에 의해 동시에 접근하면 안되는 공유 자원(e.g. 공유하는 변수 사용, 동일 파일을 사용하는 등)을 실행하는 코드 영역

![%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%203.png](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%203.png)

### 임계영역 문제(Critical Section Problem)

프로세스들이 Critical Section 을 함께 사용할 수 있는 프로토콜을 설계하는 것

### **Requirements(해결을 위한 기본조건)**

- Mutual Exclusion(상호 배제)

프로세스 P1 이 Critical Section 에서 실행중이라면, 다른 프로세스들은 그들이 가진 Critical Section 에서 실행될 수 없다.

- Progress(진행)
- Bounded Waiting(한정된 대기)

P1 가 Critical Section 에 진입 신청 후 부터 받아들여질 때가지, 다른 프로세스들이 Critical Section 에 진입하는 횟수는 제한이 있어야 한다.

## 해결책

### 1. Lock

하나의 스레드나 프로세스가 자원을 사용하고 있는 동안에는 잠궈서 접근을 하지 못하게 하는 방식

### **한계**

- 다중처리기 환경에서는 시간적인 효율성 측면에서 적용할 수 없다.

### 2. Semaphores(세마포어)

깃발이라는 뜻으로, 소프트웨어상에서 Critical Section 문제를 해결하기 위한 동기화 도구

![%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%204.png](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%204.png)

### **종류**

OS 는 Counting/Binary 세마포를 구분한다

- 카운팅 세마포

    **가용한 개수를 가진 자원** 에 대한 접근 제어용으로 사용되며, 세마포는 그 가용한 **자원의 개수** 로 초기화 된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가 한다.

- 이진 세마포

    뮤텍스(MUTEX) 라고도 부르며, 상호배제의 (Mutual Exclusion)의 머릿글자를 따서 만들어졌다. 이름 그대로 0과 1의 값만 가능하며, 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해 사용한다.

### **단점**

- Busy Waiting(바쁜 대기)

    Spin lock이라고 불리는 Semaphore 초기 버전에서 Critical Section 에 진입해야하는 프로세스는 진입 코드를 계속 반복 실행해야 하며, CPU 시간을 낭비했었다. 이를 Busy Waiting이라고 부르며 특수한 상황이 아니면 비효율적이다. 일반적으로는 Semaphore에서 Critical Section에 진입을 시도했지만 실패한 프로세스에 대해 Block시킨 뒤, Critical Section에 자리가 날 때 다시 깨우는 방식을 사용한다. 이 경우 Busy waiting으로 인한 시간낭비 문제가 해결된다.

![%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%205.png](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%205.png)

### **Deadlock(교착상태)**

> 멀티 프로그래밍 환경에서 **한정된 자원을 얻기 위해 서로 경쟁**하는 상황

세마포가 Ready Queue 를 가지고 있고, 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고, Critical Section 에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되야만 빠져나올 수 있는 상황을 지칭한다.

![%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%206.png](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%20462164adaf1e44988fc78f8d20353cf6/Untitled%206.png)

### Deadlock 해결법

1. 예방(prevention)
    - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
    - 점유대기 부정 : 프로세스 실행전 모든 자원을 할당
    - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
    - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

    자원 낭비가 심하다는 단점이 있음

2. 회피(avoidance)

    데드락이 발생하지 않는 알고리즘을 적용한다.

    - 은행원 알고리즘(Banker's Algorithm)

        은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래했다.

        프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피한다.

        안정 상태면 자원 할당을 하고, 아니면 다른 프로세스들이 자원 해지까지 대기한다.

3. 회복(Recovery)
    - 프로세스 종료 방법교착 상태의 프로세스를 모두 중지한다.교착 상태가 제거될 때까지 하나씩 프로세스를 중지한다.
    - 자원 선점 방법교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당한다. `해당 프로세스 일시정지`

        우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원을 선점한다.

4. 무시

    회복 과정의 성능 저하가 더 심하면 그냥 무시한다.

### 3. Monitor(모니터)

하나의 프로세스 내에서 다른 스레드 간의 동기화에 사용되는 추상화된 데이터 형태

- **프레임워크나 라이브러리** 그 자체에서 제공 - Java에 존재, C에 존재X

EX) synchronized, wait(), notify()